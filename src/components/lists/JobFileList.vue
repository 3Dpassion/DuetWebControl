<template>
	<div v-auto-size>
		<v-toolbar>
			<v-menu offset-y v-if="storages.length > 1">
				<v-btn color="success" slot="activator">
					<v-icon class="mr-1">sd_storage</v-icon> SD Card {{ storageIndex }} <v-icon class="ml-1">arrow_drop_down</v-icon>
				</v-btn>

				<v-list>
					<v-list-tile v-for="(storage, index) in storages" :key="index" @click="selectStorage(storage, index)">
						<v-icon class="mr-1">{{ storage.mounted ? 'done' : 'clear' }}</v-icon>
						SD Card {{ index }} ({{ storage.mounted ? 'mounted' : 'not mounted' }})
					</v-list-tile>
				</v-list>
			</v-menu>
			<directory-breadcrumbs v-model="directory"></directory-breadcrumbs>

			<v-spacer></v-spacer>

			<v-btn :loading="loading" :disabled="frozen" @click="refresh">
				<v-icon class="mr-1">refresh</v-icon> Refresh
			</v-btn>
			<upload-btn :directory="directory" target="gcodes" color="primary"></upload-btn>
		</v-toolbar>
		
		<base-file-list ref="filelist" v-model="selection" :headers="headers" :directory.sync="directory" :filelist.sync="filelist" :loading.sync="loading" @directoryLoaded="directoryLoaded" @fileClicked="fileClicked">
			<v-progress-linear slot="progress" :indeterminate="fileinfoProgress === -1" :value="(fileinfoProgress / filelist.length) * 100"></v-progress-linear>

			<template slot="no-data">
				<v-alert :value="true" type="info" class="ma-0" @contextmenu.prevent="">No Job Files</v-alert>
			</template>

			<template slot="context-menu">
				<v-list-tile v-show="isFile" @click="start">
					<v-icon class="mr-1">play_arrow</v-icon> Start File
				</v-list-tile>
				<v-list-tile v-show="isFile" @click="simulate">
					<v-icon class="mr-1">fast_forward</v-icon> Simulate File
				</v-list-tile>
			</template>
		</base-file-list>

		<confirm-dialog :shown.sync="confirmDialog.shown" :question="confirmDialog.question" :prompt="confirmDialog.prompt" @confirmed="start(confirmDialog.item)"></confirm-dialog>
	</div>
</template>

<script>
'use strict'

import { mapState, mapGetters, mapActions } from 'vuex'

import { DisconnectedError } from '../../utils/errors.js'
import Path from '../../utils/path.js'

export default {
	computed: {
		...mapGetters(['isConnected']),
		...mapState('machine', ['storages']),
		...mapGetters('ui', ['frozen']),
		isFile() {
			return (this.selection.length === 1) && !this.selection[0].isDirectory;
		},
		storageIndex() {
			const matches = /^(\d+)/.exec(this.directory);
			if (matches) {
				return parseInt(matches[1]);
			}
			return 0;
		},
		loading: {
			get() { return this.loadingValue || this.fileinfoProgress !== -1; },
			set(value) { this.loadingValue = value; }
		}
	},
	data() {
		return {
			directory: Path.gcodes,
			selection: [],
			filelist: [],
			headers: [
				{
					text: 'Filename',
					value: 'name'
				},
				{
					text: 'Size',
					value: 'size',
					unit: 'bytes'
				},
				{
					text: 'Last Modified',
					value: 'lastModified',
					unit: 'date'
				},
				{
					text: 'Object Height',
					value: 'height',
					unit: 'mm'
				},
				{
					text: 'Layer Height',
					value: 'layerHeight',
					unit: 'mm'
				},
				{
					text: 'Filament Usage',
					value: 'filament',
					unit: 'filaments'
				},
				{
					text: 'Generated by',
					value: 'generatedBy'
				}
			],
			loadingValue: false,
			fileinfoDirectory: undefined,
			fileinfoProgress: -1,
			confirmDialog: {
				question: '',
				prompt: '',
				item: undefined,
				shown: false
			}
		}
	},
	methods: {
		...mapActions(['sendCode']),
		...mapActions('machine', ['getFileInfo']),
		async selectStorage(storage, cardIndex) {
			let mountSuccess = true, mountResponse;
			this.loading = true;
			if (!storage.mounted) {
				try {
					// Mount storage
					mountResponse = await this.sendCode(`M21 P${cardIndex}`);
				} catch (e) {
					mountResponse = e.message;
					mountSuccess = false;
				}
			}
			this.loading = false;

			if (this.isConnected) {
				if (mountSuccess && storage.mounted) {
					// Change directory
					this.directory = (cardIndex === 0) ? Path.gcodes : `${cardIndex}:`;
				} else {
					// Show mount message
					this.$log('error', 'Failed to mount SD card', mountResponse);
				}
			}
		},
		refresh() {
			this.$refs.filelist.refresh();
		},
		async requestFileInfo(directory, fileIndex, fileCount) {
			if (this.fileinfoDirectory === directory) {
				if (this.isConnected && fileIndex < fileCount) {
					this.fileinfoProgress = fileIndex;
					try {
						// Request file info
						const file = this.filelist[fileIndex];
						if (!file.isDirectory) {
							const fileInfo = await this.getFileInfo(Path.combine(directory, file.name));

							// Start again if the number of files has changed
							if (fileCount !== this.filelist.length) {
								this.fileinfoProgress = 0;
								this.$nextTick(() => this.requestFileInfo(directory, 0, this.filelist.length));
								return;
							}

							// Set file info
							file.height = fileInfo.height;
							file.layerHeight = fileInfo.layerHeight;
							file.filament = fileInfo.filament;
							file.generatedBy = fileInfo.generatedBy;
						}

						// Move on to the next item
						await this.requestFileInfo(directory, fileIndex + 1, fileCount);
					} catch (e) {
						this.fileinfoProgress = -1;
						this.fileinfoDirectory = undefined;

						if (!(e instanceof DisconnectedError)) {
							console.warn(e);
							this.$log('error', this.$t('error.fileinfoRequestFailed'), e.message);
						}
					}
				} else {
					this.fileinfoProgress = -1;
					this.fileinfoDirectory = undefined;
				}
			}
		},
		directoryLoaded(directory) {
			if (this.fileinfoDirectory !== directory) {
				this.fileinfoDirectory = directory;
				this.filelist.forEach(function(item) {
					if (item.isDirectory) {
						item.height = null;
						item.layerHeight = null;
						item.filament = null;
						item.generatedBy = null;
					}
				});
				this.requestFileInfo(directory, 0, this.filelist.length);
			}
		},
		fileClicked(item) {
			this.confirmDialog.question = `Start ${item.name}`;
			this.confirmDialog.prompt = `Do you want to start ${item.name}?`;
			this.confirmDialog.item = item;
			this.confirmDialog.shown = true;
		},
		start(item) {
			this.sendCode(`M32 "${Path.combine(this.directory, (item && item.name) ? item.name : this.selection[0].name)}"`);
		},
		simulate(item) {
			this.sendCode(`M37 P"${Path.combine(this.directory, (item && item.name) ? item.name : this.selection[0].name)}"`);
		}
	}
}
</script>
